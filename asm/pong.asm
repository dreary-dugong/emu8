

# write inital sprites to screen
0x200	LD va, 0x02 # left paddle x
0x202	LD vb, 0x0c # left paddle y
0x204	LD vc, 0x3f # right paddle x
0x206	LD vd, 0x0c # right paddle y
0x208	LD I, 0x2ea # load paddle sprte location into pointer
0x20a	DRW va, vb, 6 # draw left paddle
0x20c	DRW vc, vd, 6 # draw right paddle
0x20e	LD ve, 0x00 # initialze score to 0
0x210	CALL 0x2d4 #write scores to screen



0x212	LD v6, 0x03 #inital x for ball
0x214	LD v8, 0x02

# wait 60 seconds or something
0x216	LD v0, 0x60
0x218	LD DT, v0
0x21a	LD v0, DT
0x21c	SE v0, 0x00
0x21e	JP 0x21a

# give ball random momentum
0x220	RND v7, 0x17 # v7 is a random value between 8 and 31
0x222	ADD v7, 0x08

0x224	LD v9, 0xff
0x226	LD I, 0x2f0 # draw ball sprite at inital x and random y
0x228	DRW v6, v7, 1

# user input
0x22a	LD I, 0x2ea # erase paddles
0x22c	DRW va, vb, 6
0x22e	DRW vc, vd, 6

0x230	LD v0, 0x01 # if up is pressed, subtract 2 from paddle y
0x232	SKNP v0
0x234	ADD vb, 0xfe 

0x236	LD v0, 0x04 # if down is pressed, add 2 to paddle y
0x238	SKNP v0
0x23a	ADD vb, 0x02

0x23c	LD v0, 0x1f # limit paddle y range? TODO: figure this out
0x23e	AND vb, v0
0x240	DRW va, vb, 6

# ai
0x242	LD vd, v7 # right paddle y is ball y
0x244	RND v0, 0x0a
0x246	ADD vd, 0xfe # right paddle is above the ball by 2 (center of paddle is ball y)
0x248	SNE v0, 0x00 # some unlikely chance, paddle isn't exactly equal with ball
0x24a	ADD vd, 0x02
0x24c	LD v0, 0x00

0x24e	LD v0, 0x1f # paddle bounds checking? TODO: figure this out
0x250	AND vd, v0 
0x252	DRW vc, vd, 6

# ball movement
0x254	LD I, 0x2f0 #erase ball
0x256	DRW v6, v7, 1

0x258	ADD v6, v8 # x += dx
0x25a	ADD v7, v9 # y += dy

0x25c	LD v0, 0x3f
0x25e	AND v6, v0
0x260	LD v1, 0x1f
0x262	AND v7, v1

# collision detection
0x264	SNE v6, 0x02 # if the ball is the same column as the left paddle
0x266	JP 0x278

0x268	SNE v6, 0x3f # if the ball is at the right edge of the screen
0x26a	JP 0x282

0x26c	SNE v7, 0x1f # if the ball is at the bottom of the screen, make dy -1
0x26e	LD v9, 0xff
0x270	SNE v7, 0x00 # if the ball is at the top of the screen, make dy 1
0x272	LD v9, 0x01
0x274	DRW v6, v7, 1 # draw ball
0x276	JP 0x22a # return to user input 

0x278	LD v8, 0x2 #if we're here, the ball is the same column as the left paddle
0x27a	LD v3, 0x01
0x27c	LD v0, v7
0x27e	SUB v0, vb
0x280	JP 0x28a

0x282	LD v8, 0xfe #if we're here, the ball is in the same column as the right paddle
0x284	LD v3, 0x0a
0x286	LD v0, v7
0x288	SUB v0, vd
0x28a	SE vf, 0x01
0x28c	JP 0x2a2

0x28e	LD v1, 0x02
0x290	SUB v0, v1
0x292	SE vf, 0x01
0x294	JP 0x2ba
0x296	SUB v0, v1
0x298	SE vf, 0x01
0x29a	JP 0x2c8
0x29c	SUB v0, v1
0x29e	SE vf, 0x01
0x2a0	JP 0x2c2

0x2a2	LD v0, 0x20
0x2a4	LD ST, v0
0x2a6	CALL 0x2d4
0x2a8	ADD ve, v3
0x2aa	CALL 0x2d4
0x2ac	LD v6, 0x3e
0x2ae	SE v3, 0x01
0x2b0	LD v6, 0x03
0x2b2	LD v8, 0xfe
0x2b4	SE v3, 0x01
0x2b6	LD v8, 0x02
0x2b8	JP 0x216

0x2ba	ADD v9, 0xff
0x2bc	SNE v9, 0xfe
0x2be	LD v9, 0xff
0x2c0	JP 0x2c8
0x2c2	ADD v9, 0x01
0x2c4	SNE v9, 0x02
0x2c6	LD v9, 0x01
0x2c8	LD v0, 0x04
0x2ca	LD ST, v0
0x2cc	ADD v6, 0x01
0x2ce	SNE v6, 0x40
0x2d0	ADD v6, 0xfe
0x2d2	JP 0x26c

# subroutine: write scores to screen
0x2d4	LD I, 0x2f2 # point to allocated memory
0x2d6	LD B, ve # convert ve to decimal and put the result in memory
0x2d8	LD v2, [I] # load ve decimal into registers
0x2da	LD F, v1 # load digit for left score
0x2dc	LD v4, 0x14 # left score x
0x2de	LD v5, 0x00 # left score y
0x2e0	DRW v4, v5, 5 # draw left score
0x2e2	ADD v4, 0x15 # right score x
0x2e4	LD F, v2 # load digit for right score
0x2e6	DRW v4, v5, 5 # draw right score
0x2e8	RET 

0x2ea	LD v0, v8
0x2ec	LD v0, v8
0x2ee	LD v0, v8
0x2f0	LD v0, v0
0x2f2	ERR: 0x0
0x2f4	ERR: 0x0
